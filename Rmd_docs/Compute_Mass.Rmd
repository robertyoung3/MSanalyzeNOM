---
title: "Compute Mass Function"
output: html_notebook
---

This notebook is for testing a function to compute masses from molecular formulas. It is designed for simple representations, and will be extended to cover parentheses

#### Preliminaries

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(digits = 8)
```

```{r load packages, message = FALSE}
library(tidyverse)
library(janitor)
library(here)
#data("isotopes", package = "enviPat")
```

#### Import Data File

The following code identifies the paths to all files in the "Data" folder of the working directory.

```{r get filenames}
(filenames <- list.files(here("Data"), full.names = TRUE))
```

The following code reads and cleans a sample database containing molecular formulas and SMILES structures for pure compounds, salts with counterions, and structural isomers. 

```{r read database formulas, message = FALSE}

# originally designed for a compound database with no monoisotopic masses
raw_data <- read_csv(filenames[3], na = c("", "NA", "-")) %>%
  clean_names()

cleaned_data <- raw_data %>%
  # drops formulas with counterions
  filter(!str_detect(.$smiles, pattern = "\\.")) %>%
  select(molecular_formula) %>%
  rename(MF = molecular_formula) %>%
  remove_empty("rows") %>%
  distinct() 
```

The cleaned version only contains unique molecular formulas of pure compounds. 


#### ID Elements in PFAS List

The following code contains regular expressions for extracting elements with and without the element numbers. It was copied [here] (https://www.johndcook.com/blog/2016/02/04/regular-expression-to-match-a-chemical-element/).

```{r regex patterns}
# regex to match any chemical element
regex_element <- "A[cglmrstu]|B[aehikr]|C[adeflmnorsu]|D[bsy]|E[rsu]|F[elmr]|G[ade]|H[efgos]|I[nr]|Kr|L[airuv]|M[dgnot]|N[abdeiop]|Os|P[abdmortu]|R[abefghnu]|S[bcegimnr]|T[abcehilm]|Uu[opst]|Xe|Yb|Z[nr]|[BCFHIKNOPSUVWY]"

# regex to extract element number with element
regex_element_num <- "A[cglmrstu]\\d{0,3}|B[aehikr]\\d{0,3}|C[adeflmnorsu]\\d{0,3}|D[bsy]\\d{0,3}|E[rsu]\\d{0,3}|F[elmr]\\d{0,3}|G[ade]\\d{0,3}|H[efgos]\\d{0,3}|I[nr]\\d{0,3}|Kr\\d{0,3}|L[airuv]\\d{0,3}|M[dgnot]\\d{0,3}|N[abdeiop]\\d{0,3}|Os\\d{0,3}|P[abdmortu]\\d{0,3}|R[abefghnu]\\d{0,3}|S[bcegimnr]\\d{0,3}|T[abcehilm]\\d{0,3}|Uu[opst]\\d{0,3}|Xe\\d{0,3}|Yb\\d{0,3}|Z[nr]\\d{0,3}|[BCFHIKNOPSUVWY]\\d{0,3}"
```

The following code extracts one molecular formula at random for testing.

Then, it creates a series of vectors containing components of the formula, computes the mass, and assembles a dataframe with the formula, an element table, and the monoisotopic mass.

To compute the monoisotopic mass, it uses "isotopes" data from the {enviPat} package.

```{r test one random formula, message=FALSE, warning=FALSE}
(test_formula <- sample(cleaned_data$MF, size = 1))

MF_components <- str_extract_all(test_formula, regex_element_num) %>%
  as_vector()

element <- MF_components %>%
  str_extract_all(regex_element) %>%
  as_vector()
element

num <- MF_components %>%
  str_extract_all(pattern = "\\d{1,3}") %>%
  map(function(x) if (is_empty(x)) 1 else as.numeric(x)) %>%
  as_vector()
num


get_isotopic_mass <- function (chem_element) {
  isotopes %>% 
    filter(element == chem_element) %>%
    filter(abundance == max(abundance)) %>%
    select(mass) %>%
    as_vector() %>%
    unname()
}

mass <- element %>%
  map(get_isotopic_mass) %>%
  as_vector()
mass

mass_contrib <- num * mass
(theor_mass <- sum(mass_contrib))

element_table <- tibble("element" = element, "num_element" = num) %>%
  pivot_wider(names_from = element, values_fr = num_element) %>%
  bind_cols("MF" = test_formula, 
            "theor_mass" = theor_mass) %>%
  select(MF, theor_mass, C, H, everything())
element_table

```

The following code converts the preceding into a function, which will be mapped to a vector of formulas.

```{r create compute_individual_mass function}
compute_individual_mass <- function(formula) {
  data("isotopes", package = "enviPat")
  
  # regex to match any chemical element
  regex_element <- "A[cglmrstu]|B[aehikr]|C[adeflmnorsu]|D[bsy]|E[rsu]|F[elmr]|G[ade]|H[efgos]|I[nr]|Kr|L[airuv]|M[dgnot]|N[abdeiop]|Os|P[abdmortu]|R[abefghnu]|S[bcegimnr]|T[abcehilm]|Uu[opst]|Xe|Yb|Z[nr]|[BCFHIKNOPSUVWY]"

# regex to extract element number with element
  regex_element_num <- "A[cglmrstu]\\d{0,3}|B[aehikr]\\d{0,3}|C[adeflmnorsu]\\d{0,3}|D[bsy]\\d{0,3}|E[rsu]\\d{0,3}|F[elmr]\\d{0,3}|G[ade]\\d{0,3}|H[efgos]\\d{0,3}|I[nr]\\d{0,3}|Kr\\d{0,3}|L[airuv]\\d{0,3}|M[dgnot]\\d{0,3}|N[abdeiop]\\d{0,3}|Os\\d{0,3}|P[abdmortu]\\d{0,3}|R[abefghnu]\\d{0,3}|S[bcegimnr]\\d{0,3}|T[abcehilm]\\d{0,3}|Uu[opst]\\d{0,3}|Xe\\d{0,3}|Yb\\d{0,3}|Z[nr]\\d{0,3}|[BCFHIKNOPSUVWY]\\d{0,3}"
  
  get_isotopic_mass <- function (chem_element) {
    isotopes %>% 
      filter(element == chem_element) %>%
      filter(abundance == max(abundance)) %>%
      select(mass) %>%
      as_vector() %>%
      unname()
  }

  MF_components <- stringr::str_extract_all(formula, regex_element_num) %>%
    purrr::as_vector()

  element <- MF_components %>%
    stringr::str_extract_all(regex_element) %>%
    purrr::as_vector()

  num <- MF_components %>%
    stringr::str_extract_all(pattern = "\\d{1,3}") %>%
    purrr::map(function(x) if (is_empty(x)) 1 else as.numeric(x)) %>%
    purrr::as_vector()

  mass <- element %>%
    purrr::map(get_isotopic_mass) %>%
    purrr::as_vector()

  mass_contrib <- num * mass
  theor_mass <- sum(mass_contrib)

  element_table <- tibble("element" = element, "num_element" = num) %>%
    pivot_wider(names_from = element, values_fr = num_element) %>%
    bind_cols("MF" = formula, 
              "theor_mass" = theor_mass) 
  
  if ("H" %in% colnames(element_table)) {
    element_table <- element_table %>% 
      select(MF, theor_mass, C, H, everything())
  } else {
    element_table <- element_table %>% 
      select(MF, theor_mass, C, everything())
  }

  return(element_table)
}
```

The following code tests the function.

```{r test function}
(test_formula <- sample(cleaned_data$MF, size = 1))
compute_individual_mass(test_formula)
```

Now that the function works for individual formulas, I will map it to the OECD formula list.

```{r}
test_formulas <- sample(cleaned_data$MF, size = 10)
results <- test_formulas %>% 
  map_dfr(~compute_individual_mass(.x)) %>%
  mutate_all(list(~replace_na(.,0))) %>%
  select(order(colnames(.))) 

if ("H" %in% colnames(results)) {
    results <- results %>% 
      select(MF, theor_mass, C, H, everything())
  } else {
    results <- results %>% 
      select(MF, theor_mass, C, everything())
  }
results
```

The following code creates a function that applies the {compute_individual_mass} function to a vector of masses.

```{r}
compute_accurate_masses <- function (formulas, return_data = "element_table") {
  results <- formulas %>% 
    map_dfr(~compute_individual_mass(.x)) %>%
    mutate_all(list(~replace_na(.,0))) %>%
    select(order(colnames(.))) 
  
  if ("H" %in% colnames(results)) {
    results <- results %>% 
      select(MF, theor_mass, C, H, everything())
  } else {
    results <- results %>% 
      select(MF, theor_mass, C, everything())
  }
  
  if (return_data == "formula_table") {
    results <- results %>%
      select(MF, theor_mass)
  } else if (return_data == "masses") {
    results <- results$theor_mass
  }
  return(results)
}
```

The following code applies the {compute_accurate_masses} function to a test sample.

```{r}
# "element_table", "formula_table", "masses"
test_formulas <- sample(cleaned_data$MF, size = 10)
compute_accurate_masses(test_formulas)
```

The following code requests a formula table only.

```{r}
# "element_table", "formula_table", "masses"
test_formulas <- sample(cleaned_data$MF, size = 10)
compute_accurate_masses(test_formulas, return_data = "formula_table")
```

Finally, the following code requests masses only.

```{r}
# "element_table", "formula_table", "masses"
(test_formulas <- sample(cleaned_data$MF, size = 10))
(theor_mass <- compute_accurate_masses(test_formulas, return_data = "masses"))
```